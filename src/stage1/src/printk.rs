type gfp_t = libc::c_uint;

extern "C" {
    pub fn kfree(x: *const libc::c_void);
    pub fn __kmalloc(size: libc::size_t, flags: gfp_t) -> *mut libc::c_void;
    pub fn printk(fmt: *const libc::c_char, ...);
    pub fn memcpy(dest: *mut libc::c_void, src: *const libc::c_void, count: libc::size_t);
}

const GFP_KERNEL: gfp_t = 0x90;

/// Empty structure that uses libcore's `fmt::Write` trait to provide support for writing formatted
/// Arguments lists (as generated by the built-in `format_args!()` macro`)
pub struct KernelDebugWriter {}
impl core::fmt::Write for KernelDebugWriter {
    fn write_str(&mut self, message: &str) -> core::fmt::Result {
        use crate::c_str;
        unsafe {
            let ptr =
                __kmalloc((message.len() + 1) as libc::size_t, GFP_KERNEL) as *mut libc::c_char;
            if ptr.is_null() {
                let msg = c_str!("Failed to allocate memory for dynamic printk()\n");
                let ptr = msg.as_ptr() as *const libc::c_char;
                printk(ptr);
            } else {
                memcpy(
                    ptr as *mut libc::c_void,
                    message.as_ptr() as *mut libc::c_void,
                    message.len(),
                );
                core::ptr::write(ptr.add(message.len()), 0);
                printk(ptr);
                kfree(ptr as *const libc::c_void);
            }
        }

        core::result::Result::Ok(())
    }
}

#[macro_export]
macro_rules! c_str {
    ($arg:expr) => {
        concat!($arg, '\x00')
    };
}

#[macro_export]
macro_rules! printk {
    // Static (zero-allocation) implementation that uses compile-time `concat!()` only
    ($fmt:expr) => ({
        let msg = c_str!($fmt);
        let ptr = msg.as_ptr() as *const ::libc::c_char;
        crate::printk::printk(ptr);
    });

    // Dynamic implementation that processes format arguments
    ($fmt:expr, $($arg:tt)*) => ({
        use ::core::fmt::Write;
        use printk::KernelDebugWriter;

        let mut writer = KernelDebugWriter {};
        writer.write_fmt(format_args!($fmt, $($arg)*)).unwrap();
    });
}

#[macro_export]
macro_rules! printkln {
    ($fmt:expr)              => (printk!(concat!($fmt, "\n")));
    ($fmt:expr, $($arg:tt)+) => (printk!(concat!($fmt, "\n"), $($arg)*));
}
